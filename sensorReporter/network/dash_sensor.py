# Copyright 2020 Richard Koshak
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Contains a class that uses SCAPY to scan for ARP requests from Amazon Dash
buttons that are generated when the button is pressed.
Classes:
    - DashSensor
"""
import yaml
from scapy.all import AsyncSniffer, ARP
from core.sensor import Sensor
from core.utils import get_dict_of_sequential_param__output, verify_connections_layout, \
                       configure_device_channel

class DashSensor(Sensor):
    """Uses an AsyncSniffer to watch for ARP packets generated by an Amazon Dash
    button when the button is pressed.
    """

    def __init__(self, publishers, dev_cfg):
        """Initializes and starts the background scanning for Dash Button ARP
        packets, publishing the MAC address to the destination when one is
        detected.
        """
        super().__init__(publishers, dev_cfg)

        self.log.info("Configuing Dash Scanner %s", self.name)
        self.log.debug("%s will report to following connections:\n%s",
                       self.name, yaml.dump(self.comm))

        self.devices = get_dict_of_sequential_param__output(dev_cfg, "MAC", "Destination")
        verify_connections_layout(self.comm, self.log, self.name, list(self.devices.values()))

        #configure_output for homie etc. after debug output, so self.comm is clean
        for (mac, destination) in self.devices.items():
            configure_device_channel(self.comm, is_output=True, output_name=destination,
                                     name=f"{mac} available")
        self._register(self.comm)

        if self.poll > 0:
            raise ValueError("DashSensor is not a polling sensor!")

        self.sniffer = AsyncSniffer(prn=self.arp_received, filter="arp", store=0, count=0)
        self.sniffer.start()

    def arp_received(self, pkt):
        """Called by the sniffer when an ARP packet is received. If it's from a
        device that we have a configured MAC address, we publish the MAC address
        to the configured destination.
        """
        # 1 = who-has, 2 = is-at
        if ARP in pkt and pkt[ARP].op in (1, 2):
            mac = pkt[ARP].hwsrc
            if mac in self.devices:
                self.log.info("%s dash button pressed for %s publishing to %s",
                              self.name, mac, self.devices[mac])
                self._send(mac, self.comm, self.devices[mac])

    def cleanup(self):
        """Stops and waits for the sniffer to exit."""
        self.sniffer.stop()
        self.sniffer.join()
